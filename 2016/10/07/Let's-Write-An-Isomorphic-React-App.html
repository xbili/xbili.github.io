<p>﻿—
layout: post
title: “Let’s Write an Isomorphic React App!”
date: 2016-10-07
published: true
—</p>

<h1 id="lets-write-isomorphic-react-redux">Let’s Write Isomorphic React Redux!</h1>
<p>I’ve been playing around with React for quite a bit now, and gotten pretty comfortable with Redux. I remember my first experience with React during the first assignment of CS3216. We wanted to write a simple chat application as an isomorphic Redux application, and I was leading the frontend development. It ended up in becoming a behemoth of hacks, and we eventually moved away from Redux and into Reflux. (Which wasn’t any better).</p>

<p>Fast-forward two years, I’ve been through some ups and downs with Ionic Framework for Letterbox, and a bit of React.js at work for a small data analysis tool. I think I’m ready to tackle isomorphic apps again.</p>

<p>Let’s start from the beginning shall we, none of that <code class="highlighter-rouge">react-redux-boilerplate</code> thing going on here. Everything is written from scratch.</p>

<p>(Also, it’s a Friday evening. I would love to spend time to work on something that isn’t school related. The linear algebra from Stanford’s CS229 is killing me right now)</p>

<h2 id="get-started">Get Started!</h2>
<p>I’ll be following <a href="https://codingbox.io/react-for-beginners-creating-isomorphic-react-redux-app-and-deploying-it-on-heroku-6a313f8f3693#.rk73c4upz">this article</a>.</p>

<p>First off, I’ll need to create a new Node.js app and also some eslint goodness. Right after doing <code class="highlighter-rouge">npm init</code>, here’s a few dependencies to install.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install —-save express
</code></pre>
</div>

<p>The article did mention about <code class="highlighter-rouge">webpack</code> and also <code class="highlighter-rouge">http-proxy</code>. Not sure what <code class="highlighter-rouge">http-proxy</code> is for, but I’m pretty sure <code class="highlighter-rouge">webpack</code> is needed for all those React development.I’ll go ahead and install <code class="highlighter-rouge">webpack</code> first.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install —-save webpack
</code></pre>
</div>

<p>Great catch by the article to install it as a production dependency rather than a devDependency. I’ve came across this problem when deploying React applications on Heroku previously, <code class="highlighter-rouge">webpack</code> is actually needed to build the app in production during the build process.</p>

<p><code class="highlighter-rouge">webpack-dev-server</code> and <code class="highlighter-rouge">webpack-hot-middleware</code> are both great goodies for React development too. Install them as devDependencies.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install —-save-dev webpack-dev-server webpack-hot-middleware
</code></pre>
</div>

<p>For the isomorphic app, we will need 2 services. One for rendering the template, the other for API calls. This makes it easier to scale in production. Let’s create the two entry point for the server.</p>

<p><code class="highlighter-rouge">./bin/api.js</code>
    /* eslint no-console: 0 */</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import express from 'express';

import { apiPort } from '../config/env';

const app = express();

app.get('/api', (req, res) =&gt; {
  res.send('Hello world!');
});

app.listen(apiPort, err =&gt; {
  if (err) {
    console.error(err);
  } else {
    console.info(`API listening on port ${apiPort}!`);
  }
});
</code></pre>
</div>

<p><code class="highlighter-rouge">./bin/server.js</code>
    /* eslint no-console:0 */</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import express from 'express';
import http from 'http';
import httpProxy from 'http-proxy';
import path from 'path';

import { port, apiHost, apiPort } from '../config/env';

const targetUrl = `http://${apiHost}:${apiPort}`;
const app = express();
const server = new http.Server(app);
const proxy = httpProxy.createProxyServer({
  target: targetUrl,
  ws: true,
});

app.use('/', express.static(path.resolve(__dirname, '../public')))

app.use('/api', (req, res) =&gt; {
  proxy.web(req, res, { target: `${targetUrl}/api` });
});

server.on('upgrade', (req, socket, head) =&gt; {
  proxy.ws(req, socket, head);
});

proxy.on('error', (error, req, res) =&gt; {
  if (error.code !== 'ECONNRESET') {
    console.error('proxy error', error);
  }

  if (!res.headersSent) {
    res.writeHead(500, { 'content-type': 'application/json' });
  }

  const json = { error: 'proxy_error', reason: error.message };

  res.end(JSON.stringify(json));
});

app.listen(port, err =&gt; {
  if (err) {
    console.error(err);
  } else {
    console.info(`Server listening on ${port}!`);
  }
});
</code></pre>
</div>

<p>Oh hey, it seems like we’re using <code class="highlighter-rouge">http-proxy</code> here! Let’s install that.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install —-save http-proxy
</code></pre>
</div>

<p>Now let’s break the two entry points down. Each file written is basically to start a service, one for API, and one for the template rendering server.</p>

<p><code class="highlighter-rouge">http-proxy</code> seems to be used for handling <code class="highlighter-rouge">websockets</code> requests, as shown by the config <code class="highlighter-rouge">ws: true</code>. Still not very sure what this does. But I’ll let it pass for now.</p>

<p><code class="highlighter-rouge">console.info</code> is also something that I have not seen before. Seems like a non-standard method. But that shouldn’t matter that much. This isn’t browser front facing code.</p>

<p>Now that we got this out of the way, let’s setup our <code class="highlighter-rouge">webpack-dev-server</code>! Hot-reloading and goodness ensues…</p>

<p><code class="highlighter-rouge">./bin/webpack-dev-server.js</code>
    /* eslint import/no-extraneous-dependencies: 0, no-console: 0 */</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import express from 'express';
import webpack from 'webpack';

const { host, port, webpackPort } = require('../config/env');

const webpackConfig = {};

const compiler = webpack(webpackConfig);

const serverOptions = {
  contentBase: `http://${host}:${port}`,
  quiet: true,
  noInfo: true,
  hot: true,
  inline: true,
  lazy: false,
  publicPath: webpackConfig.output.publicPath,
  headers: { 'Access-Control-Allow-Origin': '*' },
  stats: { colors: true },
};

const app = express();

app.use(require('webpack-dev-middleware')(compiler, serverOptions));
app.use(require('webpack-hot-middleware')(compiler));

app.listen(webpackPort, err =&gt; {
  if (err) {
    console.error(err);
  } else {
    console.log(`Webpack development server listening on port ${webpackPort}`);
  }
});
</code></pre>
</div>

<p>Setting up a <code class="highlighter-rouge">webpack-dev-server</code> is still pretty standard, similar to non-isomorphic React.</p>

<p>Now we need <code class="highlighter-rouge">concurrently</code> to run both services together.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install —-save concurrently
</code></pre>
</div>

<p>I’m pretty sure Node.js <code class="highlighter-rouge">harmony</code> mode supports most of ES6/7 features right now, but just to be sure (we’re deploying a production app, eh!), I’m still going to rely on Babel. Here’s the ton of Babel goodies to install.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install —-save babel-loader babel-cli babel-preset-latest babel-preset-react babel-preset-stage-0
</code></pre>
</div>

<p>Note that I saved it as dependency instead of dev dependency too, for the same reasons as saving <code class="highlighter-rouge">webpack</code> as a core dependency.</p>

<p>Here’s the corresponding <code class="highlighter-rouge">.babelrc</code>:
    {
        “presets”: [
            “latest”,
            “stage-0”,
            “react”
        ]
    }</p>

<p>Let’s update <code class="highlighter-rouge">package.json</code> to run our servers concurrently too:
    “scripts”: {
      “start”: “concurrently –kill-others "npm run start-api" "npm run start-server" "npm run webpack-dev-server"”,
      “start-api”: “NODE_ENV=development babel-node ./bin/api.js”,
      “start-server”: “NODE_ENV=development babel-node ./bin/server.js”,
      “webpack-dev-server”: “NODE_ENV=development babel-node ./bin/webpack-dev-server.js”,
      “test”: “echo "Error: no test specified" &amp;&amp; exit 1”
    }</p>

<p>That’s pretty much all we need to get started. Quite a bit eh? The next part comes the main headache. <strong>Webpack</strong>. Remember the <code class="highlighter-rouge">webpack.config</code> that we magically defined? Yeah.</p>

<h2 id="webpack-configuration">Webpack Configuration</h2>
<p>I had to take a walk before moving on to this section. I know it will tedious.</p>

<p>Let’s begin.</p>

<p>First up, we need an entry file. Let’s create <code class="highlighter-rouge">./src/index.js</code>.
    console.log(‘Hello world!’);</p>

<p>Let’s create a development webpack config first.</p>

<p><code class="highlighter-rouge">webpack/dev.config.js</code>
    const path = require(‘path’);
    const webpack = require(‘webpack’);</p>

<div class="highlighter-rouge"><pre class="highlight"><code>const assetsPath = path.resolve(__dirname, '../public/assets');

const { webpackHost, webpackPort } = require('../config/env');

module.exports = {
  devtool: 'inline-source-map', // sourcemap added as data url to js file
  context: path.resolve(__dirname, '..'), // base directory
  entry: {
    main: [
      `webpack-hot-middleware/client?path=http://${webpackHost}:${webpackPort}/__webpack_hmr`, // hot reloading
      './src/index.js',
    ],
  },
  output: {
    path: assetsPath,
    filename: '[name].js', // for chunking
    chunkFilename: '[name]-[chunkhash].js', // for long term caching
    publicPath: `http://${webpackHost}:${webpackPort}/assets/`,
  },
  module: {
    loaders: [
      {
        test: /\.jsx?$/,
        exclude: /(node_modules|bower_components)/,
        loader: 'babel',
      },
    ],
  },
  progress: true, // show progress bar
  resolve: {
    modulesDirectories: [
      'node_modules',
      'src',
      // add more resolve directories here to prevent nested ../../..
    ],
    extensions: ['', '.json', '.js', '.jsx'],
  },
  plugins: [
    new webpack.HotModuleReplacementPlugin(), // hot reloading
    new webpack.IgnorePlugin(/webpack-stats\.json$/), // (???) still not very sure what this does...
  ],
};
</code></pre>
</div>

<p>As I’ve done this a couple of times, I understand some of the configurations. Those that are new will be commented.</p>

<p>Cool, now running <code class="highlighter-rouge">npm start</code> will start both services, and heading to either <code class="highlighter-rouge">http://localhost:3001</code> or <code class="highlighter-rouge">http://localhost:3002</code> will return ‘Hello world!’ on the browser.</p>

<h2 id="react">React</h2>
<p>Now that we got configuration out of the way, it’s time to work on React. (Couple of configurations to take note of too)</p>

<p>Install ALL the React dependencies that we need right now!</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install -—save react react-dom serialize-javascript redux react-redux react-router react-router-redux pretty-error
</code></pre>
</div>

<p>Only a few new packages that I have never used before:
1. <code class="highlighter-rouge">serialize-javascript</code> - meant to serialize the store for future deserialization on the client
2. <code class="highlighter-rouge">pretty-error</code> - self explanatory</p>

<p>Time to write the first React component that renders the entire HTML markup for our app!</p>

<p><code class="highlighter-rouge">src/layouts/Default.jsx</code>
    /* eslint react/prefer-stateless-function: 0, react/no-danger: 0, react/forbid-prop-types: 0 */</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import React, { Component } from 'react';
import ReactDOM from 'react-dom/server'; // For server use!
import serialize from 'serialize-javascript';
import { webpackHost, webpackPort } from '../../config/env';

export default class Default extends Component {
  render() {
    const { component, store } = this.props;
    const content = component ? ReactDOM.renderToString(component) : '';

    return (
      <span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;head&gt;</span>
          <span class="nt">&lt;title&gt;</span>Hello, Supperfly!<span class="nt">&lt;/title&gt;</span>
        <span class="nt">&lt;/head&gt;</span>
        <span class="nt">&lt;body&gt;</span>
          <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"root"</span> <span class="na">dangerouslySetInnerHTML=</span><span class="err"> </span><span class="s">/</span><span class="nt">&gt;</span>
          <span class="nt">&lt;script
            </span><span class="na">src=</span><span class="s">{</span>
              <span class="na">process</span><span class="err">.</span><span class="na">env</span><span class="err">.</span><span class="na">NODE_ENV =</span><span class="s">==</span> <span class="err">'</span><span class="na">development</span><span class="err">'</span> <span class="err">?</span>
              <span class="err">`</span><span class="na">http:</span><span class="err">//${</span><span class="na">webpackHost</span><span class="err">}</span><span class="na">:</span><span class="err">${</span><span class="na">webpackPort</span><span class="err">}/</span><span class="na">assets</span><span class="err">/</span><span class="na">main</span><span class="err">.</span><span class="na">js</span><span class="err">`</span> <span class="na">:</span> <span class="err">'/</span><span class="na">assets</span><span class="err">/</span><span class="na">main</span><span class="err">.</span><span class="na">js</span><span class="err">'</span>
            <span class="err">}</span>
            <span class="na">charSet=</span><span class="s">"UTF-8"</span>
          <span class="nt">/&gt;</span><span class="err">
        &lt;/body&gt;
      &lt;/html&gt;
    );
  }
}

Default.propTypes = {
  component: React.PropTypes.node,
  store: React.PropTypes.object,
};
</span></code></pre>
</div>

<p>This still looks very familiar, a normal React component, with different locations to fetch static assets from depending on the environment the app is running in.</p>

<p>Here comes a slightly more hairy part, updating <code class="highlighter-rouge">server.js</code>. This is only hairy for isomorphic apps, because the server has the speak the language of having a ‘store’, and also the concept of ‘routing’.</p>

<p>Here’s the end product of <code class="highlighter-rouge">bin/server.js</code>
    /* eslint no-console:0 */</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import express from 'express';
import http from 'http';
import httpProxy from 'http-proxy';
import path from 'path';
import PrettyError from 'pretty-error';
import React from 'react';
import ReactDOM from 'react-dom/server'; // for server use!
import { match, RouterContext } from 'react-router'; // ?
import { syncHistoryWithStore } from 'react-router-redux';
import createHistory from 'react-router/lib/createMemoryHistory'; // ?
import { Provider } from 'react-redux';

import {
  createStore
} from '../src/redux/createStore';
import getRoutes from '../src/routes';
import Default from '../src/layouts/Default';
import { port, apiHost, apiPort } from '../config/env';

const targetUrl = `http://${apiHost}:${apiPort}`;
const pretty = new PrettyError();
const app = express();
const server = new http.Server(app);
const proxy = httpProxy.createProxyServer({
  target: targetUrl,
  ws: true,
});

app.use('/', express.static(path.resolve(__dirname, '../public')));

app.use('/api', (req, res) =&gt; {
  proxy.web(req, res, { target: `${targetUrl}/api` });
});

server.on('upgrade', (req, socket, head) =&gt; {
  proxy.ws(req, socket, head);
});

proxy.on('error', (error, req, res) =&gt; {
  if (error.code !== 'ECONNRESET') {
    console.error('proxy error', error);
  }

  if (!res.headersSent) {
    res.writeHead(500, { 'content-type': 'application/json' });
  }

  const json = { error: 'proxy_error', reason: error.message };

  res.end(JSON.stringify(json));
});

app.use((req, res) =&gt; {
  const memoryHistory = createHistory(req.originalUrl);
  const store = createStore(memoryHistory);
  const history = syncHistoryWithStore(memoryHistory, store);

  function hydrateOnClient() {
    res.send(`&lt;!doctype html&gt;${ReactDOM.renderToString(&lt;Default store={store} /&gt;)}`);

    match({ history, routes: getRoutes(store), location: req.originalUrl }, (error, redirectLocation, renderProps) =&gt; {
      if (redirectLocation) {
        // It's a redirect route, just do a simple redirect
        res.redirect(redirectLocation.pathname + redirectLocation.search);
      } else if (error) {
        console.error('ROUTER ERROR:', pretty.render(error));
        res.status(500);
        hydrateOnClient();
      } else if (renderProps) {
        // Props you should pass to the routing context if the route matched.
        const component = (
          &lt;Provider store={store} key="provider"&gt;
            &lt;RouterContext {...renderProps} /&gt;
          &lt;/Provider&gt;
        )

        res.status(200);

        global.navigator = { userAgent: req.headers['user-agent'] }; // ?

        res.send(`&lt;!doctype html&gt;${ReactDOM.renderToStaticMarkup(&lt;Default component={component} store={store} /&gt;)}`);
      } else {
        res.status(404).send('Not found');
      }
    });
  }
})

app.listen(port, err =&gt; {
  if (err) {
    console.error(err);
  } else {
    console.info(`Server listening on ${port}!`);
  }
});
</code></pre>
</div>

<p>That’s a really long file. As always, I annotated some of the things I have never seen before in the code itself. (With several question marks)</p>

<p>This is good progress for today, at least I have a basic boilerplate code setup for development, and would want to configure it for more robust development processes in time to come.</p>

<p>The next step will be to create React containers for my app, and it shall be done another day. It’s 12am and I have a sleep at midnight policy right now.</p>

<p>Hopefully more progress can be made this weekend! Time to push the code and hit the sacks. :)</p>
